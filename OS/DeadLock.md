## 교착 상태(Dead Lock)
> 두 스레드가 서로 상대방이 쥐고 있는 자물쇠가 풀리기만을 기다리면서 서로 가로막고 있는 상황.

<br>

- 두개의 서로 다른 스레드에서 서로 상대방이 필요로 하는 자원에 대한 락을 가지고 있는 경우에 발생
- 멀티 프로그래밍 환경에서 한정된 자원을 사용하려고 경쟁하는 상황(`Race Condition`)에서 발생할 수 있다. 

 <br>

- 프로세스가 자원을 요청했을 때 바로 사용할 수 없는 경우 프로세스는 대기 상태가 된다.  
- 대기 상태에서 프로세스들이 실행 상태로 변경될 수 없는 경우를 일컫는다. 
- 예를 들면 `Process1`과 `Process2`가 각각 `Resource A, B`를 얻어야 한다면, `P1`이 `A`를 선점하고 `P2`가 `B`를 선점한다면 두 프로세스는 무한정 기다리게 된다. 

<br>

- 보통 해결 방법은 한 스레드를 강제로 종료 시키는것
- 가장 좋은 해결책은 데드락이 일어날 상황을 피하는 것이다. 

### 데드락의 발생 조건
- 상호 배제(Mutual Exclusion)  
 : 자원은 한번에 한 프로세스만 사용할 수 있다.
- 점유 대기(Hold and wait)  
 : 최소 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야한다. 
- 비선점(No Preemption)  
 : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 뺏을 수 없다.
- 순환 대기(Circular wait)  
 : 대기하고 있는 프로세스들은 순차적으로 앞의 프로세스가 점유한 자원에 대기하며 마지막 프로세스는 첫번째 프로세스가 점유한 자원을 요구한다. 

### 데드락의 처리
#### 예방(Prevention)
: 교착 상태 발생 조건을 제거해 해결하는 방법.  

- 상호 배제 부정  
 : 여러 프로세스가 공유 자원을 사용하도록한다.
- 점유 대기 부정  
 : 프로세스가 실행되기 전에 필요한 모든 자원을 할당하낟.
- 비선점 부정  
 : 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고 요구한 자원을 사용하기 위해 기다리게한다. 
- 순환대기 부정  
 : 자원에 고유한 번호를 할당해 번호 순서대로 자원을 요구하도록 한다. 

#### 회피(Avoidance) 
: 교착 상태가 발생하면 피하는 방법.

- 은행원 알고리즘(Banker's Algorithm)
: 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태인지 사전에 검사한다.
: 안정상태에 있는 경우 자원을 할당하고 그렇지 않으면 다른 프로세스들이 자원을 해지할 때까지 대기한다.

#### 탐지(Detection)
: 자원 할당 그래프를 통해 교착 상태를 탐지한다.

- 자원 요청할 때마다 탐지 알고리즘을 실행하기 때문에 오버헤드가 발생한다. 

#### 회복(Recovery)
: 교착 상태를 일으킨 `프로세스를 종료`하거나, 할당된 `자원을 해제`해 회복하는 방법.

- 프로세스 종료
    - 교착 상태의 프로세스를 모두 중지한다.
    - 교착 상태가 제거될 때까지 한 프로세스씩 중지한다.
- 자원 선점
    - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에세 할당해 해당 프로레스를 일시 정지 시킨다.
    - 우선 순위가 낮은 프로세스, 수행된 횟수가 적은 프로세스 등을 위주로 프로세스 자원을 선점한다. 