# Memory Mapping
> 물리 메모리와 가상 메모리의 대응
- OS가 물리 메모리와 가상 메모리 사이에 프로그램이나 데이터를 대응 시키는 것을 `Mapping`이라 한다. 

## Paging (페이징)
- `고정 길이` 페이지 단위(4KB)로 매핑을 수행하는 기법.
- 논리(가상)메모리는 `페이지(Page)`라 불리는 고정 크기 블록, 물리 메모리는 `프레임(Frame)`이라 불리는 페이지와 같은 크기의 고정 크기 블록으로 나눈 뒤 `페이지 테이블`에서 페이지-프레임을 매핑해 관리하는 기법
- 프로세스의 일부만 메모리에 로드한 뒤 나머지는 보조기억장치에 둔다. 
- `고정 크기`이므로 **연속적인 물리 메모리가 아니더라도 원하는 크기의 프레임을 사용할 수 있다.**
- 고정 크기 이므로 외부 단편화를 해결할 수 있지만 내부 단편화가 발생한다. 
- 페이지 아웃 : 물리 > 가상 메모리
- 페이지 인 : 물리 < 가상 메모리 (우선 순위 높은 페이지를 물리 메모리의 페이지 프레임에 전송)
- 페이징이 번번히 일어나는 것은 `Thrashing(스레싱)`이라 하는데 이는 CPU 이용 효율 저하의 원인이 된다. 
- Page Fault(페이지 폴트) : 물리 메모리에 페이지 프레임이 없으면 발생하는 인터럽트

## Segmentation (세그먼테이션)
- `가변 길이` 세그먼트 단위로 매핑을 수행하는 기법.
- 가상메모리를 `서로 크기가 다른 논리적 단위`인 세그먼트로 분할하고 메모리를 할당해 주소 변환을 한다.
- `각각의 세그먼트`들은 `연속적인 공간`에 저장되어 있다.
- 세그먼트들의 크기가 다르기 때문에 메모리를 페이징 기법처럼 분할해 둘 수 없고, `메모리에 적재될 때` 빈 공간을 찾아 `할당`한다. 
- Mapping을 위해 세그먼트 테이블이 필요하다.
- 하나의 세그먼트 단위로 통제하기 때문에 내부 단편화가 발생하지 않는 대신 외부 단편화가 생길 수 있다. 
- 세그먼테이션이 빈번하게 일어나면 Fragmentation(프레그먼테이션)이 발생해 Compaction(메모리 집약)을 수행해야한다. 

### 페이징과 세그먼테이션의 예(x86)
- 메모리 레이아웃과 같이 `커널-스택-공유라이브러리-힙-BSS-데이터-코드` 각각 영역으로 나눈 기술을 `세그먼테이션`이라 한다.  
    - 각각 다른 크기를 논리적 블록으로 연속해 배치한다.  
    - 각 영역의 기능, 권한, 필요한 공간의 크기가 모두 달라 세그먼테이션으로 분할해 메모리를 관리하는 것.  

  
- 어셈블리 코드가 모두 각각 동일한 크기로 할당되는 것이 `페이징` 기법이다.  


- x86은 세그먼테이션으로 메모리 전체 레이아웃을 분할하고, 프로세스가 요구하는 작업을 동일한 크기로 쪼개 페이지 단위로 단위를 처리한다.   


### 참고
- https://m.blog.naver.com/s2kiess/220149980093
- https://sycho-lego.tistory.com/10
